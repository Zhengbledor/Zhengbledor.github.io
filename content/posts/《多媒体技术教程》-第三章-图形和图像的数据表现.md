+++
title = "《多媒体技术教程》-第三章-图形和图像的数据表现"
date = "2023-03-17"
math = true
+++

# 第三章-图形和图像的数据表现

## 1、图形/图像的数据类型

### 1.1 1位图像

图像由像素组成，像素是数字图像中的图片元素，可以理解为图片中的一个一个点。

如果一张图片中的像素由Boolean储存，只有“开”和“关”两个属性，展示出来的效果是“黑”和“白”。这样的图像称为“**二值图像**”

**二值图像**又被称为**1位单色图像**。如果不做其他的压缩操作，一张分辨率（分辨率的定义可以看博客中另一篇文章，后面会在这里加超链接）为640*480的1位单色图像需要38.4kB的存储空间。（防止有些小可爱不知道怎么算的，加上过程= =）
$$
(640 * 480) =307,200 (Bit) \\\\ {307,200 \over 8} = {38400(Byte)} ={38.4(kB)}
$$

### 1.2 8位灰度图像

8位灰度图像指图像的每一个像素都存储了一个0-255(1Byte)的灰度值(gray value)。

8位图像可以看成由像素值组成的二维数组，其中的两个维度分别为长、宽。这样一个二维数组被称为一幅位图(bitmap)。而存储位图的硬件设备位帧缓存(frame buffer)，而帧缓存被封装在视频卡中。

> 帧缓(frame buffer)冲设备提供了显卡的抽象描述。他同时代表了显卡上的显存，应用程序通过定义好的接口可以访问显卡，而不需要知道底层的任何操作。

每个像素通常用一个字节存储，所以一副640*480的灰度图需要300KB的存储空间。

如果我们想通过打印机打印这样一幅图片。老式的1位打印机通常只能选择打印一个点或者不打印一个点，不能指定灰度进行打印。所以一个8位的灰度图像可能会被打印成一张1位单色图。

此时采用抖动(dithering)方法，它的基本操作是以亮度分辨率换取空间分辨率。

**抖动**

如果我们用n\*n的开关1位点矩阵来替代，就能表现n^2+1级亮度分辨率。也就是说每一个像素在打印机上都会被视作n\*n个像素。并为其中n*n个点编号。
$$
\begin{bmatrix}
0 & 2 \\\\
3 & 1
\end{bmatrix}
$$
比如矩阵中任意三点被打印成黑色可以算作一个亮度级。那么我们就选择使用2*2的开关去替代，就可以表示5级亮度分辨率。

首先通过256/5的整数除法把0-255间的图像值映射到一个新的范围0-4。

如果像素值为0，则打印机在这2*2的矩阵内不输出任何打印，如果像素值是4，那么在这4个点都涂满。

所以规则如下：

> 如果像素亮度比抖动矩阵的某个元素编号大，则在该元素填涂，即用一个n*n的点阵替换每个像素。

注意，对于一个经过抖动方法处理的图像，其尺寸可能太大，比如使用4*4的点阵替换每个像素，会使图像变为原来的16倍。可以使用有序抖动的方式去解决这个问题

**有序抖动**

假设我们用一个更大的4*4抖动矩阵，如
$$
\begin{bmatrix}
0 & 8 & 2 & 10 \\\\
12 & 4 & 14 & 6 \\\\
3 & 11 & 1 & 9 \\\\
15 & 7 & 13 & 5
\end{bmatrix}
$$
然后假设我们把这个抖动矩阵在同一时刻移动到图像在水平和垂直方向上的四个像素上，如果某个像素的亮度值大于覆盖它的矩阵元素编号，则这个像素被涂黑。

一个使用n*n抖动矩阵的算法为

```
begin
	for x=0 to xmax
		for y=0 to ymax
			i=x mod n
			j=y mod n
			//I(x,y)为输入，O(x,y)为输出,D为抖动矩阵
			if I(x,y)>D(i,j)
				O(x,y) = 1
			else
				O(x,y) = 0
end
```

### 1.3 24位彩色图像

在一个24位彩色图像中，每个像素用3个字节储存，通常表示位RGB（红绿蓝），因为每个值的范围是0-255，所以这种格式支持表示256\*256\*256种颜色。但是这种灵活性会带来存储的问题。一幅640*480的24位彩色图如果不经过压缩需要921kB的存储空间。

需要注意的重点是，许多24位彩色图像通常表示为32位图像，除去表示RGB的24位以外，还有8位(1字节)用来表示α(alpha)，用作图像在该像素点的透明度。

### 1.4 8位彩色图

许多系统只能通过8位颜色信息(也称作256色)来生成屏幕图像。