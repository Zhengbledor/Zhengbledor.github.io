<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zhengbledor</title>
    <link>https://zhengbledor.github.io/</link>
    <description>Recent content on Zhengbledor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 02 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://zhengbledor.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>创建型-原型模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-原型模式 Link to heading 原型模式主要解决的问题就是创建重复对象，而这部分对象内容本身比较复杂，生成过程可能从库或者RPC接口中获取数据的耗时较长，因此采用克隆的方式节省时间。
这种场景就像CV代码、java中的clone一样。
模拟场景 Link to heading 一个上机考试抽题服务，做到能够混排题目，混排答案。这个服务用于选择题、问答题的试卷创建。
数据准备
public class ChoiceQuestion{ private String name; private Map&amp;lt;String, String&amp;gt; option; private String key; public ChoiceQuestion(String name. Map&amp;lt;String, String&amp;gt; option, String key){ this.name = name; this. option = option; this. key = key; } } public class AnswerQuestion{ private String name; private String key; public AnswerQuestion(String name,String key){ this.name = name; this.key = key; } } 最初设计 Link to heading public class QuestionBankController{ public String createPaper(Stirng candidate, String number){ // do sth // 手工填写不同问题 } } 这样的代码非常容易理解，要什么题目就塞进去，只面向过程，不考虑扩展性。</description>
    </item>
    
    <item>
      <title>创建型-建造者模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-建造者模式 Link to heading 建造者模式所完成的内容就是通过将多个简单对象通过一步步的组装构建出一个复杂对象的过程。
模拟场景 Link to heading 模拟装修公司对于设计出一些套餐装修服务的场景
吊顶、涂料、地板、地砖等
最初设计 Link to heading 物料接口
public interface Matter { String scene(); // 场景 String brand();	// 品牌 String model(); // 型号 BigDecimal price();	// 价格 String desc();	// 描述 } 使用
public class DecorationPackageController{ public List&amp;lt;Matter&amp;gt; getMaterList(BigDecimal area, int type){ List&amp;lt;Matter&amp;gt; list = new ArrayList&amp;lt;Matter&amp;gt;(); BigDecimal price = BigDecimal.Zero; if(1 == type){ // do something } else(2 == type){ // do something } else(3 == type){ // do somgting } return list; } } 改进方案 Link to heading 工程结构</description>
    </item>
    
    <item>
      <title>创建型-抽象工厂模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-抽象工厂模式 Link to heading 抽象工厂模式也可以叫其他工厂模式，它可以在抽象工厂中创建出其他工厂，与工厂模式一样，都是用来解决接口选择的问题。
场景模拟 Link to heading 此前业务使用的数据库为单机Redis
但是随着业务的发展，此前的单机Redis已经无法适用于项目，所以需要升级成健壮的Redis集群服务。
很多服务都用到Redis，需要一起升级。 需要同时兼容集群EGM和IIR 两套集群的接口不一样，需要同时做兼容 不能影响目前正常运行的系统 最初设计 Link to heading 给接口添加Redis集群使用类型，以控制使用哪套集群服务。 但是不能停止已经使用的集群，所以还保留了此前单机的Redis接口。 工程结构
├─application │ ├─CacheService.java │ └─CacheServiceImpl.java └─redis ├─RedisUtils.java └─cluster ├─EGM.java └─IIR.java 服务定义
public class EGM { private Map&amp;lt;String, String&amp;gt; dataMap = new ConcurrentHashMap&amp;lt;&amp;gt;(); public String gain(String key) { return dataMap.get(key); } public void set(String key, String value) { dataMap.put(key, value); } public void delete(String key) { dataMap.remove(key); } } public class IIR { private Map&amp;lt;String, String&amp;gt; dataMap = new ConcurrentHashMap&amp;lt;&amp;gt;(); public String get(String key) { return dataMap.</description>
    </item>
    
    <item>
      <title>创建型-单例模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-单例模式 Link to heading 7种单例模式的创建 Link to heading 单例模式的实现方式比较多，主要在实现上是否支持懒汉模式、是否线程安全中运用各种技巧。 当然也有一些场景不需要考虑懒加载的情况，会直接使用static静态累或属性和方法的方式进行处理，供外部调用。
0. 静态类使用 Link to heading public class Singleton_00{ public static Map&amp;lt;String, String&amp;gt; cache = new ConcurrentHashMap&amp;lt;String, String&amp;gt;(); } 这样的静态类的方式可以在第一次运行的时候直接初始化Map类，不需要到延迟加载在使用。 1. 懒汉模式（线程不安全） Link to heading public class Singleton_01 { private static Singleton_01 instance; private Singleton_01() { } public static Singleton_01 getInstance(){ if (null != instance) return instance; instance = new Singleton_01(); return instance; } } 有一个特点就是外部不允许直接创建，只能通过Singleton_01.getInstance()来初始化创建该单例。 这种方式的范例确实满足了懒加载，但是如果多个访问者同时进入getInstance()中可能会出现同时存在多个实例的问题。 2. 懒汉模式（线程安全） Link to heading public class Singleton_02 { private static Singleton_02 instance; private Singleton_02() { } public static synchronized Singleton_02 getInstance(){ if (null !</description>
    </item>
    
    <item>
      <title>创建型-工厂模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-工厂模式 Link to heading 工厂模式又称为简单工厂模式，属于创建型设计模式的一种。
这种设计模式提供了按需创建对象的最佳方式。不会对外暴露创建细节，并且会通过一个统一的接口创建所需的对象。
它主要的意图是定义一个创建对象的接口，让其子类自己决定将哪一个工厂类实例化，工厂模式使创建过程延迟到子类中进行。
场景模拟 Link to heading 模拟发放多种奖品，在营销场景中，经常会约定在用户完成打卡、分享、留言、邀请注册等一系列行为操作后进行返利积分的操作。用户再通过返利积分兑换奖品，让整个系统构成一个生态闭环。
现假设有以下三种类型的商品接口。
// 优惠券 CouponResult sendCoupon(String uId, String couponNumber, String uuid); // 实物商品 Boolean deliverGoods(DeliverReq req); // 第三方兑换卡 void grantToken(String bindMobileNumber, String cardId); 三个接口返回值类型不同，入参不同，并且未来可能会扩展的兑换场景。
最初设计 Link to heading 工程结构
├─AwardReq.java ├─AwardRes.java └─PrizeController.java 实现
public class PrizeController{ public AwardRes awardToUser(AwardReq req){ if(req.type == &amp;#34;优惠券&amp;#34;){ // do something CouponResult result = sendCoupon(req.uId,req.conponNumber,req.uuid); return AwardRes(result); }else if(req.type == &amp;#34;实物&amp;#34;){ DelilverReq deliverReq = new DeliverReq(); // do something Boolean result = deliverGoods(deliverReq); return AwardRes(result); }else if(req.</description>
    </item>
    
    <item>
      <title>六大设计原则</title>
      <link>https://zhengbledor.github.io/posts/designprinciples/</link>
      <pubDate>Tue, 28 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/designprinciples/</guid>
      <description>Design Principles Link to heading 一、单一职责原则 Link to heading 一个类应该只有一个发生变化的原因。
模拟场景 Link to heading 一个视频网站有对用户分类的场景
访客用户只能观看480P视频，且有广告 普通会员只能观看720P视频，且有广告 VIP用户可以看1080P视频，且无广告
违背原则 Link to heading public class VideoUserSerice{ public void serveGrade(String usrType){ if(usrType == &amp;#34;VIP&amp;#34;){ // 视频1080P，无广告 }else if(usrType == &amp;#34;普通会员&amp;#34;){ // 视频720P，有广告 }else if(usrType == &amp;#34;访客用户&amp;#34;){ // 视频480P，有广告 } } } 改进方案 Link to heading public interface IVideoUserService{` // 清晰度 1080P、720P、480P void definition(); // 广告播放方式，有广告、无广告 void advertisement(); } 二、开闭原则 Link to heading 对象、类、模块和函数对扩展应该是开放的，但是对于修改是封闭的。</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://zhengbledor.github.io/about/</link>
      <pubDate>Tue, 28 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/about/</guid>
      <description>郑布利多的博客，平时记载一点技术、生活的文章(万一哪天被裁了)</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>https://zhengbledor.github.io/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/contact/</guid>
      <description>Follow me, @Zhengbledor.</description>
    </item>
    
  </channel>
</rss>
