<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zhengbledor</title>
    <link>https://zhengbledor.github.io/posts/</link>
    <description>Recent content in Posts on Zhengbledor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 02 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://zhengbledor.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>创建型-原型模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-原型模式 Link to heading 原型模式主要解决的问题就是创建重复对象，而这部分对象内容本身比较复杂，生成过程可能从库或者RPC接口中获取数据的耗时较长，因此采用克隆的方式节省时间。
这种场景就像CV代码、java中的clone一样。
模拟场景 Link to heading 一个上机考试抽题服务，做到能够混排题目，混排答案。这个服务用于选择题、问答题的试卷创建。
数据准备
public class ChoiceQuestion{ private String name; private Map&amp;lt;String, String&amp;gt; option; private String key; public ChoiceQuestion(String name. Map&amp;lt;String, String&amp;gt; option, String key){ this.name = name; this. option = option; this. key = key; } } public class AnswerQuestion{ private String name; private String key; public AnswerQuestion(String name,String key){ this.name = name; this.key = key; } } 最初设计 Link to heading public class QuestionBankController{ public String createPaper(Stirng candidate, String number){ // do sth // 手工填写不同问题 } } 这样的代码非常容易理解，要什么题目就塞进去，只面向过程，不考虑扩展性。</description>
    </item>
    
    <item>
      <title>创建型-建造者模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-建造者模式 Link to heading 建造者模式所完成的内容就是通过将多个简单对象通过一步步的组装构建出一个复杂对象的过程。
模拟场景 Link to heading 模拟装修公司对于设计出一些套餐装修服务的场景
吊顶、涂料、地板、地砖等
最初设计 Link to heading 物料接口
public interface Matter { String scene(); // 场景 String brand();	// 品牌 String model(); // 型号 BigDecimal price();	// 价格 String desc();	// 描述 } 使用
public class DecorationPackageController{ public List&amp;lt;Matter&amp;gt; getMaterList(BigDecimal area, int type){ List&amp;lt;Matter&amp;gt; list = new ArrayList&amp;lt;Matter&amp;gt;(); BigDecimal price = BigDecimal.Zero; if(1 == type){ // do something } else(2 == type){ // do something } else(3 == type){ // do somgting } return list; } } 改进方案 Link to heading 工程结构</description>
    </item>
    
    <item>
      <title>创建型-抽象工厂模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-抽象工厂模式 Link to heading 抽象工厂模式也可以叫其他工厂模式，它可以在抽象工厂中创建出其他工厂，与工厂模式一样，都是用来解决接口选择的问题。
场景模拟 Link to heading 此前业务使用的数据库为单机Redis
但是随着业务的发展，此前的单机Redis已经无法适用于项目，所以需要升级成健壮的Redis集群服务。
很多服务都用到Redis，需要一起升级。 需要同时兼容集群EGM和IIR 两套集群的接口不一样，需要同时做兼容 不能影响目前正常运行的系统 最初设计 Link to heading 给接口添加Redis集群使用类型，以控制使用哪套集群服务。 但是不能停止已经使用的集群，所以还保留了此前单机的Redis接口。 工程结构
├─application │ ├─CacheService.java │ └─CacheServiceImpl.java └─redis ├─RedisUtils.java └─cluster ├─EGM.java └─IIR.java 服务定义
public class EGM { private Map&amp;lt;String, String&amp;gt; dataMap = new ConcurrentHashMap&amp;lt;&amp;gt;(); public String gain(String key) { return dataMap.get(key); } public void set(String key, String value) { dataMap.put(key, value); } public void delete(String key) { dataMap.remove(key); } } public class IIR { private Map&amp;lt;String, String&amp;gt; dataMap = new ConcurrentHashMap&amp;lt;&amp;gt;(); public String get(String key) { return dataMap.</description>
    </item>
    
    <item>
      <title>创建型-桥接模式</title>
      <link>https://zhengbledor.github.io/posts/%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>结构型-桥接模式 Link to heading 桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。
【GOF95】在提出桥梁模式的时候指出，桥梁模式的用意是&amp;quot;将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化&amp;quot;。这句话有三个关键词，也就是抽象化、实现化和脱耦。
下列各语言的代码都用于写出两个不同的圆的坐标和半径。
/** &amp;#34;Implementor&amp;#34; */ interface DrawingAPI{ public void drawCircle(double x, double y, double radius); } /** &amp;#34;ConcreteImplementor&amp;#34; 1/2 */ class DrawingAPI1 implements DrawingAPI{ public void drawCircle(double x, double y, double radius){ System.out.printf(&amp;#34;API1.circle at %f:%f radius %f\n&amp;#34;, x, y, radius); } } /** &amp;#34;ConcreteImplementor&amp;#34; 2/2 */ class DrawingAPI2 implements DrawingAPI{ public void drawCircle(double x, double y, double radius){ System.out.printf(&amp;#34;API2.circle at %f:%f radius %f\n&amp;#34;, x, y, radius); } }/** &amp;#34;Abstraction&amp;#34; */ interface Shape{ public void draw(); // low-level public void resizeByPercentage(double pct); // high-level } /** &amp;#34;Refined Abstraction&amp;#34; */ class CircleShape implements Shape{ private double x, y, radius; private DrawingAPI drawingAPI; public CircleShape(double x, double y, double radius, DrawingAPI drawingAPI){ this.</description>
    </item>
    
    <item>
      <title>创建型-组合模式</title>
      <link>https://zhengbledor.github.io/posts/%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>结构型-组合模式 Link to heading 组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。
模拟场景 Link to heading 我们有一个类 Employee，该类被当作组合模型类。
public class Employee { private String name; private String dept; private int salary; private List&amp;lt;Employee&amp;gt; subordinates; //构造函数 public Employee(String name,String dept, int sal) { this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList&amp;lt;Employee&amp;gt;(); } public void add(Employee e) { subordinates.add(e); } public void remove(Employee e) { subordinates.remove(e); } public List&amp;lt;Employee&amp;gt; getSubordinates(){ return subordinates; } public String toString(){ return (&amp;#34;Employee :[ Name : &amp;#34;+ name +&amp;#34;, dept : &amp;#34;+ dept + &amp;#34;, salary :&amp;#34; + salary+&amp;#34; ]&amp;#34;); } } // 使用 public class CompositePatternDemo { public static void main(String[] args) { Employee CEO = new Employee(&amp;#34;John&amp;#34;,&amp;#34;CEO&amp;#34;, 30000); Employee headSales = new Employee(&amp;#34;Robert&amp;#34;,&amp;#34;Head Sales&amp;#34;, 20000); Employee headMarketing = new Employee(&amp;#34;Michel&amp;#34;,&amp;#34;Head Marketing&amp;#34;, 20000); Employee clerk1 = new Employee(&amp;#34;Laura&amp;#34;,&amp;#34;Marketing&amp;#34;, 10000); Employee clerk2 = new Employee(&amp;#34;Bob&amp;#34;,&amp;#34;Marketing&amp;#34;, 10000); Employee salesExecutive1 = new Employee(&amp;#34;Richard&amp;#34;,&amp;#34;Sales&amp;#34;, 10000); Employee salesExecutive2 = new Employee(&amp;#34;Rob&amp;#34;,&amp;#34;Sales&amp;#34;, 10000); CEO.</description>
    </item>
    
    <item>
      <title>创建型-适配器模式</title>
      <link>https://zhengbledor.github.io/posts/%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>结构型-适配器模式 Link to heading 将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作。
其中主要有三个角色
目标角色：该角色定义把其他类转换为何种接口，也就是我们的期望接口。
源角色：你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象。
适配器角色：通过继承或是类关联的方式把源角色转换为目标角色。
场景模拟 Link to heading 中国的充电器无法在英国使用，需要使用适配器。
类适配器 Link to heading 适配器通过类来实现，以类来继承和实现接口的方式，来获取被适配类的信息并转换输出重写到适配接口。
public class ChineseStandard{ public String getChineseStandard(){ return &amp;#34;中式插座&amp;#34;; } } public class interfaceBritishStandard{ String getBritishStandard(); } public StandardAdapter extends ChineseStandard implements interfaceBritishStandard{ @Override public String getBritishStandard(){ return this.getChineseStandard(); } } 对象适配器 Link to heading 通过实例对象（构造器传递）来实现适配器，而不是再用继承，其余基本同类适配器。
public StandardAdapter implements interfaceBritishStandard{ private ChineseStandard chineseStandard = new ChineseStandard(); @Override public String getBritishStandard(){ return chineseStandard.</description>
    </item>
    
    <item>
      <title>创建型-单例模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-单例模式 Link to heading 7种单例模式的创建 Link to heading 单例模式的实现方式比较多，主要在实现上是否支持懒汉模式、是否线程安全中运用各种技巧。 当然也有一些场景不需要考虑懒加载的情况，会直接使用static静态累或属性和方法的方式进行处理，供外部调用。
0. 静态类使用 Link to heading public class Singleton_00{ public static Map&amp;lt;String, String&amp;gt; cache = new ConcurrentHashMap&amp;lt;String, String&amp;gt;(); } 这样的静态类的方式可以在第一次运行的时候直接初始化Map类，不需要到延迟加载在使用。 1. 懒汉模式（线程不安全） Link to heading public class Singleton_01 { private static Singleton_01 instance; private Singleton_01() { } public static Singleton_01 getInstance(){ if (null != instance) return instance; instance = new Singleton_01(); return instance; } } 有一个特点就是外部不允许直接创建，只能通过Singleton_01.getInstance()来初始化创建该单例。 这种方式的范例确实满足了懒加载，但是如果多个访问者同时进入getInstance()中可能会出现同时存在多个实例的问题。 2. 懒汉模式（线程安全） Link to heading public class Singleton_02 { private static Singleton_02 instance; private Singleton_02() { } public static synchronized Singleton_02 getInstance(){ if (null !</description>
    </item>
    
    <item>
      <title>创建型-工厂模式</title>
      <link>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型-工厂模式 Link to heading 工厂模式又称为简单工厂模式，属于创建型设计模式的一种。
这种设计模式提供了按需创建对象的最佳方式。不会对外暴露创建细节，并且会通过一个统一的接口创建所需的对象。
它主要的意图是定义一个创建对象的接口，让其子类自己决定将哪一个工厂类实例化，工厂模式使创建过程延迟到子类中进行。
场景模拟 Link to heading 模拟发放多种奖品，在营销场景中，经常会约定在用户完成打卡、分享、留言、邀请注册等一系列行为操作后进行返利积分的操作。用户再通过返利积分兑换奖品，让整个系统构成一个生态闭环。
现假设有以下三种类型的商品接口。
// 优惠券 CouponResult sendCoupon(String uId, String couponNumber, String uuid); // 实物商品 Boolean deliverGoods(DeliverReq req); // 第三方兑换卡 void grantToken(String bindMobileNumber, String cardId); 三个接口返回值类型不同，入参不同，并且未来可能会扩展的兑换场景。
最初设计 Link to heading 工程结构
├─AwardReq.java ├─AwardRes.java └─PrizeController.java 实现
public class PrizeController{ public AwardRes awardToUser(AwardReq req){ if(req.type == &amp;#34;优惠券&amp;#34;){ // do something CouponResult result = sendCoupon(req.uId,req.conponNumber,req.uuid); return AwardRes(result); }else if(req.type == &amp;#34;实物&amp;#34;){ DelilverReq deliverReq = new DeliverReq(); // do something Boolean result = deliverGoods(deliverReq); return AwardRes(result); }else if(req.</description>
    </item>
    
    <item>
      <title>六大设计原则</title>
      <link>https://zhengbledor.github.io/posts/designprinciples/</link>
      <pubDate>Tue, 28 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhengbledor.github.io/posts/designprinciples/</guid>
      <description>Design Principles Link to heading 一、单一职责原则 Link to heading 一个类应该只有一个发生变化的原因。
模拟场景 Link to heading 一个视频网站有对用户分类的场景
访客用户只能观看480P视频，且有广告 普通会员只能观看720P视频，且有广告 VIP用户可以看1080P视频，且无广告
违背原则 Link to heading public class VideoUserSerice{ public void serveGrade(String usrType){ if(usrType == &amp;#34;VIP&amp;#34;){ // 视频1080P，无广告 }else if(usrType == &amp;#34;普通会员&amp;#34;){ // 视频720P，有广告 }else if(usrType == &amp;#34;访客用户&amp;#34;){ // 视频480P，有广告 } } } 改进方案 Link to heading public interface IVideoUserService{` // 清晰度 1080P、720P、480P void definition(); // 广告播放方式，有广告、无广告 void advertisement(); } 二、开闭原则 Link to heading 对象、类、模块和函数对扩展应该是开放的，但是对于修改是封闭的。</description>
    </item>
    
  </channel>
</rss>
